\section{Related work}\label{sec-related}

\subsection{Arrows}

...

\subsection{Static analysis}

The idea of using the \hs{Const} functor for static analysis is not new.
See, for example,~\citet{free-applicatives}.

\subsection{Parsers and \hs{Alternative} type class}

\hs{Alternative} is a type class originally motivated by non-monadic parsers;
see, for example,~\citet{swierstra1996parsers}, where the methods of the
\hs{Alternative} type class appear as part a bigger \hs{Parsing} type class. In
modern Haskell, \hs{Alternative} is a subclass of \hs{Applicative}:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
class Applicative f => Alternative f where
    empty :: f a
    (<|>) :: f a -> f a -> f a
\end{minted}
\vspace{1mm}

\noindent
The operator \hs{<|>} allows us to naturally express \emph{choice} in parsers.
As an example, consider the task of parsing binary and hexadecimal numbers,
which are prefixed with \hs{"0b"} and \hs{"0x"}, respectively. Following the
classic parser combinator approach~\citep{hutton1998monadic}, let us assume the
existence of the following parsers:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
sat    :: (Char -> Bool) -> Parser Char   -- parse a specified character
string :: String         -> Parser String -- parse a specified string
bin    ::                   Parser Int    -- parse a binary-encoded number
hex    ::                   Parser Int    -- parse a hexadecimal-encoded number
\end{minted}
\vspace{1mm}

\noindent
Now the desired parser can be obtained as a choice between parsers for binary
and hexadecimal numbers, each augmented with the prefix-parsing part:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
numberA :: Parser Int
numberA = (string "0b" *> bin) <|> (string "0x" *> hex)
\end{minted}
\vspace{1mm}

\noindent
When parsing \hs{"0x7E3"}, the first parser fails (due to the prefix mismatch),
but the second one succeeds. Note that parsing of the leading \hs{"0"} can be
factored out into a separate parser \hs{string}~\hs{"0"} to avoid backtracking.

Selective functors also allow us to implement the desired parser, and arguably
in a more direct style that does not involve trying one parser after another:

\vspace{1mm}
\begin{minted}[xleftmargin=10pt]{haskell}
numberS :: Parser Int
numberS = ifS ((== 'b') <$> (string "0" *> sat (`elem` "bh"))) bin hex
\end{minted}
\vspace{1mm}

\noindent
Here we first parse the leading \hs{"0"}, then the second character of the
prefix, failing if it is neither \hs{"b"} nor \hs{"h"}, and finally select an
appropriate subsequent parser using \hs{ifS}.

Investigation of the relationship between \hs{Alternative} and \hs{Selective}
type classes, as well as application of selective functors to parsers is left
for future work.

% Anything else?
% Kleisli functors
% https://elvishjerricco.github.io/2016/10/12/kleisli-functors.html
